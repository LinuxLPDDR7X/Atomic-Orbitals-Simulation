<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Oxygen Orbitals — Lightweight Visualizer (fixed)</title>
<style>
  :root{--bg:#0b0b0f;--ui:#111217;--accent:#6ec1ff;--muted:#9aa4b2}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef8}
  #app{display:grid;grid-template-columns:1fr 340px;height:100vh}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#000000,#071226)}
  .panel{padding:14px;background:linear-gradient(180deg,var(--ui),#0a0a0e);box-shadow:0 6px 24px rgba(0,0,0,.6);}
  h1{margin:0 0 12px;font-size:18px}
  label{display:block;margin:10px 0 6px;font-size:13px;color:var(--muted)}
  select,input[type=range]{width:100%}
  .row{display:flex;gap:8px}
  button{background:transparent;border:1px solid #25313a;color:#cfe9ff;padding:8px 10px;border-radius:8px;cursor:pointer}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:12px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div id="app">
  <div style="position:relative">
    <canvas id="gl" width="1200" height="900"></canvas>
    <div style="position:absolute;left:12px;bottom:12px;color:#9fbcd8;font-size:13px;background:rgba(2,6,12,.3);padding:6px 10px;border-radius:8px">Drag to rotate • Scroll to zoom • Click orbit to toggle</div>
  </div>
  <aside class="panel">
    <h1>Oxygen Orbitals Visualizer</h1>
    <div class="small">Lightweight 2D canvas projection of 3D orbitals — outlines & soft fills so no heavy GPU needed.</div>

    <label>Choose view</label>
    <select id="view">
      <option value="all">Show all orbitals</option>
      <option value="1s">1s (spherical)</option>
      <option value="2s">2s (spherical node)</option>
      <option value="2px">2p<sub>x</sub></option>
      <option value="2py">2p<sub>y</sub></option>
      <option value="2pz">2p<sub>z</sub></option>
      <option value="cloud">Electron cloud (full)</option>
    </select>

    <label>Rendering style</label>
    <div class="row">
      <button id="outline">Outline</button>
      <button id="filled">Soft fill</button>
      <button id="points">Points</button>
    </div>

    <label>Opacity of fill / points</label>
    <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.45">
    <div id="opacityVal" class="small">Opacity: 0.45</div>

    <label>Scale</label>
    <input id="scale" type="range" min="0.5" max="2" step="0.01" value="1">

    <label>Auto-rotate</label>
    <div class="row"><button id="autorotate">Toggle</button><div style="flex:1" id="rotspeedLabel" class="small">Speed: 0.02</div></div>
    <input id="rotspeed" type="range" min="0" max="0.12" step="0.001" value="0.02">

    <label>Background</label>
    <div class="row"><button id="bgInvert">Invert</button><button id="reset">Reset View</button></div>

    <footer>
      <strong>Notes:</strong> This is a pedagogical visualization (textbook-looking). It uses simple projection math and sampled points for the cloud so it's lightweight on machines without a GPU.
    </footer>
  </aside>
</div>

<script>
// Lightweight 3D -> 2D projection helper, no WebGL, only Canvas2D
const canvas = document.getElementById('gl');
const ctx = canvas.getContext('2d');
let W = canvas.width = canvas.clientWidth;
let H = canvas.height = canvas.clientHeight;
let DPR = Math.max(1, window.devicePixelRatio || 1);
canvas.width = Math.floor(canvas.clientWidth * DPR);
canvas.height = Math.floor(canvas.clientHeight * DPR);
ctx.setTransform(DPR,0,0,DPR,0,0);
W = canvas.clientWidth; H = canvas.clientHeight;

// Camera / interaction
let cam = {rx: -0.4, ry: 0.4, dist: 260, fov: 800};
let dragging=false, last={x:0,y:0};
canvas.addEventListener('pointerdown', e=>{dragging=true; last={x:e.clientX,y:e.clientY}; canvas.setPointerCapture(e.pointerId)});
canvas.addEventListener('pointermove', e=>{if(!dragging) return; const dx=(e.clientX-last.x), dy=(e.clientY-last.y); cam.ry+=dx*0.006; cam.rx+=dy*0.006; last={x:e.clientX,y:e.clientY};});
window.addEventListener('pointerup', ()=>dragging=false);
canvas.addEventListener('wheel', e=>{e.preventDefault(); cam.dist += e.deltaY*0.25; cam.dist = Math.min(Math.max(100,cam.dist),800);}, {passive:false});

// UI
const ui = {
  view: document.getElementById('view'),
  outline: document.getElementById('outline'),
  filled: document.getElementById('filled'),
  pointsBtn: document.getElementById('points'),
  opacity: document.getElementById('opacity'),
  opacityVal: document.getElementById('opacityVal'),
  scale: document.getElementById('scale'),
  autorotateBtn: document.getElementById('autorotate'),
  rotspeed: document.getElementById('rotspeed'),
  rotspeedLabel: document.getElementById('rotspeedLabel'),
  bgInvert: document.getElementById('bgInvert'),
  reset: document.getElementById('reset')
};

let renderMode = 'filled';
ui.outline.onclick = ()=>renderMode='outline';
ui.filled.onclick = ()=>renderMode='filled';
ui.pointsBtn.onclick = ()=>renderMode='points';

let autoRot = false;
ui.autorotateBtn.onclick = ()=>autoRot = !autoRot;
ui.rotspeed.oninput = ()=>{ui.rotspeedLabel.textContent = 'Speed: '+ui.rotspeed.value};
ui.reset.onclick = ()=>{cam = {rx:-0.4, ry:0.4, dist:260, fov:800}};

// show opacity value next to slider
ui.opacity.oninput = ()=>{ ui.opacityVal.textContent = 'Opacity: '+ui.opacity.value };

// Resize handling
window.addEventListener('resize', ()=>{
  canvas.width = Math.floor(canvas.clientWidth * DPR);
  canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = canvas.clientWidth; H = canvas.clientHeight;
});

// Basic 3D helpers
function rotateY(p, a){ const s=Math.sin(a), c=Math.cos(a); return {x: p.x*c + p.z*s, y:p.y, z:-p.x*s + p.z*c}; }
function rotateX(p, a){ const s=Math.sin(a), c=Math.cos(a); return {x:p.x, y:p.y*c - p.z*s, z:p.y*s + p.z*c}; }
function project(p){ const z = p.z + cam.dist; const s = cam.fov / z; return {x: W/2 + p.x*s, y: H/2 - p.y*s, s}; }

// Create geometries (samples) for orbitals — not quantum-accurate, just textbook shapes
function makeSphereSamples(radius=80, rings=28, segments=40){
  const pts = [];
  for(let i=0;i<rings;i++){
    const v = (i/(rings-1))*Math.PI - Math.PI/2; // -pi/2 to pi/2
    for(let j=0;j<segments;j++){
      const u = (j/segments)*Math.PI*2;
      const x = radius * Math.cos(v)*Math.cos(u);
      const y = radius * Math.cos(v)*Math.sin(u);
      const z = radius * Math.sin(v);
      pts.push({x,y,z});
    }
  }
  return pts;
}

function makeEllipsoidSamples(rx=60, ry=25, rz=60, center={x:0,y:0,z:0}, density=30){
  const pts=[];
  for(let i=0;i<density;i++){
    const t = i/(density-1)*Math.PI - Math.PI/2;
    for(let j=0;j<density;j++){
      const s=j/density*2*Math.PI;
      const x = rx * Math.cos(t)*Math.cos(s) + center.x;
      const y = ry * Math.sin(t) + center.y;
      const z = rz * Math.cos(t)*Math.sin(s) + center.z;
      pts.push({x,y,z});
    }
  }
  return pts;
}

// p-orbital approx: two lobes from ellipsoids along axis
function makePLobes(axis='x', size=80){
  const L = 60;
  const r = 36;
  const l1 = makeEllipsoidSamples(r, r*0.5, r, {x: axis==='x'?L:0, y: axis==='y'?L:0, z: axis==='z'?L:0}, 26);
  const l2 = makeEllipsoidSamples(r, r*0.5, r, {x: axis==='x'?-L:0, y: axis==='y'?-L:0, z: axis==='z'?-L:0}, 26);
  return l1.concat(l2);
}

// 2s: look like a sphere with a nodal sphere (ring) — we'll draw inner and outer spheres
const geom = {
  '1s': makeSphereSamples(70, 26, 36),
  '2s_outer': makeSphereSamples(110, 28, 42),
  '2s_inner': makeSphereSamples(60, 22, 34),
  '2px': makePLobes('x'),
  '2py': makePLobes('y'),
  '2pz': makePLobes('z')
};

// Electron cloud: random points with more density in p-lobes and s shells
let cloudPoints = [];
function generateCloud(n=4000){
  cloudPoints = [];
  for(let i=0;i<n;i++){
    // randomly pick shell: 1s (0.2), 2s (0.15), 2p (0.65)
    const r = Math.random();
    if(r<0.2){ // 1s — gaussian radial
      const radius = Math.abs(randGaussian())*40 + 10; // concentrated near origin
      const ang = Math.random()*Math.PI*2; const incl = Math.acos(2*Math.random()-1);
      const x = radius*Math.sin(incl)*Math.cos(ang), y=radius*Math.sin(incl)*Math.sin(ang), z=radius*Math.cos(incl);
      cloudPoints.push({x,y,z,alpha:0.06});
    } else if(r<0.35){ // 2s - more spread, node
      const radius = Math.abs(randGaussian())*50 + 60; // outer shell
      const ang = Math.random()*Math.PI*2; const incl = Math.acos(2*Math.random()-1);
      const x = radius*Math.sin(incl)*Math.cos(ang), y=radius*Math.sin(incl)*Math.sin(ang), z=radius*Math.cos(incl);
      cloudPoints.push({x,y,z,alpha:0.04});
    } else { // 2p — biased into lobes along axes (show combined px,py,pz cloud)
      const axis = Math.floor(Math.random()*3);
      const sign = Math.random()<0.5?1:-1;
      const along = sign*(Math.abs(randGaussian())*40 + 40);
      // place around axis
      let x=0,y=0,z=0;
      if(axis===0){x = along; y=(randGaussian()*12); z=(randGaussian()*12);} 
      else if(axis===1){y = along; x=(randGaussian()*12); z=(randGaussian()*12);} 
      else {z = along; x=(randGaussian()*12); y=(randGaussian()*12);} 
      cloudPoints.push({x,y,z,alpha:0.035});
    }
  }
}

// gaussian helper (Box-Muller)
function randGaussian(){
  let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// Color palette (base RGB values)
const BASE_COLORS = {
  '1s': [255,205,80],      // warm gold
  '2s_outer': [80,220,120],
  '2s_inner': [200,85,170],
  '2px': [255,110,80],     // orange
  '2py': [60,200,120],     // greenish
  '2pz': [120,140,255],    // purple/blue
  'cloud': [180,220,255]
};
function colorRgb(name){ const c = BASE_COLORS[name] || [200,200,200]; return { stroke: `rgba(${c[0]},${c[1]},${c[2]},0.95)`, fill: `rgb(${c[0]},${c[1]},${c[2]})` } }

// Draw functions
function drawSamples(samples, opts={stroke:'#88d4ff', fill:true, alpha:0.08, fillColor:null, lineWidth:1}){
  // transform & project
  const trans = samples.map(p=> rotateX(rotateY(p, cam.ry), cam.rx) );
  const proj = trans.map(p=> ({p, screen:project(p)}));
  // sort by depth (far -> near so nearer draw last)
  proj.sort((a,b)=> (b.p.z - a.p.z));

  ctx.save();
  ctx.lineWidth = opts.lineWidth || 1.0;
  ctx.strokeStyle = opts.stroke || ctx.strokeStyle;
  // fillColor should be an "rgb(...)" string (no alpha) so globalAlpha controls overall opacity
  if(opts.fillColor) ctx.fillStyle = opts.fillColor;
  // combine orbital alpha with UI opacity (globalAlpha will multiply stroke/fill)
  ctx.globalAlpha = (opts.alpha ?? 0.08) * Number(ui.opacity.value);

  if(renderMode==='points'){
    for(const item of proj){
      const s = Math.max(0.8, item.screen.s*0.4*Number(ui.scale.value));
      ctx.beginPath(); ctx.arc(item.screen.x, item.screen.y, s, 0, Math.PI*2); ctx.fill();
    }
  } else {
    // Draw faint wireframe by drawing each ring as a polyline if available
    const ringLenGuess = Math.round(samples.length / 26) || 30;
    for(let i=0;i<samples.length;i+=ringLenGuess){
      ctx.beginPath();
      for(let j=0;j<ringLenGuess;j++){
        const k = i + j; if(k>=proj.length) break;
        const s = proj[k].screen; if(j===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
      }
      ctx.closePath();
      ctx.stroke();
    }
    if(opts.fill && renderMode==='filled'){
      // soft fill using many translucent points (respecting globalAlpha)
      for(const item of proj){
        const s = Math.max(0.9, item.screen.s*0.5*Number(ui.scale.value));
        ctx.beginPath(); ctx.arc(item.screen.x, item.screen.y, s, 0, Math.PI*2); ctx.fill();
      }
    }
  }
  ctx.restore();
}

function drawCloud(points){
  // sample and draw many tiny circles
  const trans = points.map(p=> rotateX(rotateY(p, cam.ry), cam.rx) );
  const proj = trans.map(p=> ({p, screen:project(p)}));
  proj.sort((a,b)=> b.p.z - a.p.z);
  ctx.save();
  // cloud color base (no alpha here — alpha comes from each point's alpha * ui.opacity)
  const c = BASE_COLORS['cloud']; ctx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
  for(const item of proj){
    const s = Math.max(0.6, item.screen.s*0.07*Number(ui.scale.value));
    ctx.globalAlpha = (item.p.alpha || 0.03) * Number(ui.opacity.value);
    ctx.beginPath(); ctx.arc(item.screen.x, item.screen.y, s, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// Styles helper (keeps some defaults)
function setStyles(){ ctx.lineWidth = 1.0; ctx.strokeStyle = 'rgba(120,190,255,0.9)'; ctx.fillStyle = `rgba(110,193,255,${Number(ui.opacity.value)})`; }

// Main loop
let lastTime=0;
function render(t){
  const dt = (t-lastTime)/1000||0; lastTime=t;
  if(autoRot) cam.ry += Number(ui.rotspeed.value) * dt * 60;
  ctx.clearRect(0,0,W,H);

  // nucleus
  ctx.save();
  const nuc = project(rotateX(rotateY({x:0,y:0,z:0}, cam.ry), cam.rx));
  ctx.beginPath(); ctx.arc(nuc.x, nuc.y, 6*Number(ui.scale.value), 0, Math.PI*2); ctx.fillStyle='#ffd48a'; ctx.fill(); ctx.strokeStyle='rgba(255,210,140,.7)'; ctx.stroke();
  ctx.restore();

  setStyles();
  ctx.globalCompositeOperation = 'source-over';

  const view = ui.view.value;
  const op = Number(ui.opacity.value);

  if(view==='all' || view==='1s'){
    const col = colorRgb('1s');
    if(view!=='all' && view!=='cloud') drawSamples(geom['1s'], {alpha:0.12, fill:true, stroke:col.stroke, fillColor:col.fill});
    if(view==='all') drawSamples(geom['1s'], {alpha:0.08, fill:true, stroke:col.stroke, fillColor:col.fill});
  }
  if(view==='all' || view==='2s'){
    const colO = colorRgb('2s_outer');
    const colI = colorRgb('2s_inner');
    drawSamples(geom['2s_outer'], {alpha:0.07, fill:true, stroke:colO.stroke, fillColor:colO.fill});
    drawSamples(geom['2s_inner'], {alpha:0.05, fill:true, stroke:colI.stroke, fillColor:colI.fill});
  }
  if(view==='all' || view==='2px'){
    const col = colorRgb('2px');
    drawSamples(geom['2px'], {alpha:0.08, fill:true, stroke:col.stroke, fillColor:col.fill});
  }
  if(view==='all' || view==='2py'){
    const col = colorRgb('2py');
    drawSamples(geom['2py'], {alpha:0.08, fill:true, stroke:col.stroke, fillColor:col.fill});
  }
  if(view==='all' || view==='2pz'){
    const col = colorRgb('2pz');
    drawSamples(geom['2pz'], {alpha:0.08, fill:true, stroke:col.stroke, fillColor:col.fill});
  }

  if(view==='cloud'){
    // draw cloud only
    drawCloud(cloudPoints);
  } else if(view==='all'){
    // extra faint cloud to show electrons
    ctx.save(); ctx.globalAlpha = 0.03; ctx.fillStyle = 'rgb(200,220,255)'; drawCloud(cloudPoints.slice(0,1200)); ctx.restore();
  }

  requestAnimationFrame(render);
}

// initial generation
generateCloud(2500);
requestAnimationFrame(render);

// regenerate cloud when view changes
ui.view.onchange = ()=>{
  if(ui.view.value==='cloud') generateCloud(6000); else generateCloud(2500);
}

// quick pick: click on canvas toggles between orbitals
canvas.addEventListener('click', (e)=>{
  const pick = ui.view.value;
  const order = ['all','1s','2s','2px','2py','2pz','cloud'];
  let i = order.indexOf(pick);
  i = (i+1) % order.length; ui.view.value = order[i]; ui.view.dispatchEvent(new Event('change'));
});

// small touch: default render mode
renderMode = 'filled';

</script>
</body>
</html>
